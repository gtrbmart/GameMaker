<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sMeiMei</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Initialize Variables

/* Movement Variables (pixels per frame)*/

//set input variables
kDown = 0;
kUp = 0;
kLeft = 0;
kRight = 0;
kJump = 0;
//set gravity 
grav = 0.5;
//set horizontal speed 
vx = 0;
vxCarry = 0;
vy = 0;
vyCarry = 0;
//motion variables
dir = 0;
dirPrevious = 0;
momentum = 0;
fric = 1; 
airFric = 0.1; 
maxSpeed = 5;
moveSpeed = 2; //horizontal acceleration
//set jump variables
jumping = 0;
wallJumping = 0;
jumps = 0;
jumpsMax = 2;
jumpSpeedNormal = 8;
jumpSpeedPowerUp = 12;
jumpSpeed = jumpSpeedNormal;
jumpFrames = 0;
hspWallCling = 0;
maxAirSpeed = 4;
//wall clinging
wallClingTimeS = 0;
maxWallClingTimeS = 0.5;
vxWallCling = floor(maxSpeed * 0.75);
vyWallCling = floor(jumpSpeed * 0.75);

//set power up settings
JumpPowerUpTime = 250;

//OnGround
OnGround = 0;

//TouchingWall
TouchingWall = 0;

//warp to checkpoint if one is active
if(global.checkpointRoom == room)
{
    x = global.checkpointx;
    y = global.checkpointy;
}

//Time variables
steps = 0;
seconds = 0;
minutes = 0;

//check if we're on the ground
if(place_meeting(x,y+1,oSolid))
{
    OnGround = 1;
    jumps = jumpsMax;
}
else
{
    OnGround = 0;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Set up states

enum state
{
    Standing,
    Running,
    Jumping,
    Falling,
    WallClinging
}

State = state.Standing;
nextState = state.Standing;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Remove Jump PowerUp
jumpSpeed = jumpSpeedNormal;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Step Event
steps++;
//figure out time (seconds wraps around at 60 seconds)
minutes = floor((steps/room_speed)/60);
seconds = floor(steps/room_speed) - (minutes * 60);
/* Input */

//get right
kRight = keyboard_check(ord("D"));
//get left
kLeft = -keyboard_check(ord("A"));
//get down
kDown = keyboard_check(ord("S"));
//get up
kUp = -keyboard_check(ord("W"));
//get jump
kJump = keyboard_check_pressed(vk_space);
kJumpHold = keyboard_check(vk_space);
//get esc
kEsc = keyboard_check_pressed(vk_escape);

if(kEsc)
{
    game_end();
}

if(place_meeting(x,y+1,oSolid))
{
    OnGround = 1;
    jumps = jumpsMax;
}
else
{
    OnGround = 0;
}

TouchingWall = 0; //don't need to set this twice, so set it to 0 and then see if the walls are on left or right
if(place_meeting(x+1, y, oSolid))
{
    TouchingWall = 1;
}

if(place_meeting(x-1, y, oSolid))
{
    TouchingWall = -1;
}

//move left or right
//grab direction from previous movement
if(dir != 0) dirPrevious = dir;
//move can equal -1, 0, 1 
//-1 is left, 0 is no movement, 1 is right
dir = kLeft + kRight; 

//state machine
switch (State)
{
    case state.Standing:  //!!!!***STANDING***!!!!//
        sprite_index = sMeiMei;
        
        if(dir != 0)
        {
            vx += (dir * moveSpeed);
            nextState = state.Running;
        }
        
        if(kJump)
        {
    
            vy = -jumpSpeed;
            nextState = state.Jumping;
        }
        
        if(!OnGround)
        {
            vy = ApplyGravity(vy, grav);
            nextState = state.Falling;
        }
        
        break;
    case state.Running:  //!!!!***RUNNING***!!!!//
        sprite_index = sMeiMeiRun;
        image_speed = 1;
        
        if(dir != 0)  //if player is trying to move 
        {
            vx += (dir * moveSpeed);
            if(abs(vx) &gt; maxSpeed)
            {
                vx = dir * maxSpeed;
            }
        }
        else
        {
            if(vx != 0) 
            {
                vx = ApplyFriction(vx, fric);
            }
        }
        
        if(vx == 0)  //if we have any x velocity
        {
            nextState = state.Standing;
        }       
        
        if(kJump)
        {
            vy = -jumpSpeed;
            nextState = state.Jumping;
        }
        
        if(!OnGround)
        {
            vy = ApplyGravity(vy, grav);
            nextState = state.Falling;
        }
        
        if(TouchingWall)
        {
            vx = 0;
            nextState = state.Standing;
        }
        
        break;
    case state.Jumping:  //!!!!***JUMPING***!!!!//
        sprite_index = sMeiMeiJump;    
        
        
    
        if(dir != 0)  //if player is trying to move 
        {
            vx += (dir * moveSpeed);
            if(abs(vx) &gt; maxSpeed)
            {
                vx = sign(vx) * maxSpeed;
            }
        }
        else  //if we have any x velocity
        {
           if (vx != 0) 
           {
              vx = ApplyFriction(vx, airFric);
           }        
        }
        
        //allow variable jumping speed/height based on jump key hold time
        if((vy &lt; 0) &amp;&amp; (!kJumpHold))
        {
            vy = max(vy, -jumpSpeed/4);
        }
        
        //allow double jumps
        if(kJump &amp;&amp; (jumps &gt; 0))
        {
            jumps--;
            vy += -jumpSpeed;
        }
        
        //apply gravity
        vy = ApplyGravity(vy, grav);
        
        if((vy &gt;=0) &amp;&amp; (TouchingWall == 0))
        {
            nextState = state.Falling;
        } 
        
        if(TouchingWall != 0)
        {
            nextState = state.WallClinging;
        }
        
        break;
    case state.Falling:  //!!!!***FALLING***!!!!//
        sprite_index = sMeiMeiFall; 
        
        if(dir != 0)  //if player is trying to move 
        {
            vx += (dir * moveSpeed);
            if(abs(vx) &gt; maxAirSpeed)
            {
                vx = sign(vx) * maxAirSpeed;
            }
        }
        else  //if we have any x velocity
        {
           if (vx != 0) 
           {
                vx += -(sign(vx) * airFric); //apply air friction
                if(abs(vx) &lt; airFric)
                {
                    vx = 0;
                }
           }
        }
        
        //allow double jumps
        if(kJump &amp;&amp; (jumps &gt; 0))
        {
            jumps--;
            vy += -jumpSpeed;
        }
        
        //apply gravity
        vy = ApplyGravity(vy, grav);
        
        if(OnGround)
        {
            if(vx == 0)
            {
                nextState = state.Standing;
            }
            else
            {
                nextState = state.Running;
            }
        }
        break;
    case state.WallClinging:
         if(wallClingTimeS &lt; maxWallClingTimeS) //do this while we're wall clinging
         {
            if(wallClingTimeS == 0)
            {
                vy = 0;
                vx = 0;
            }
            wallClingTimeS += (1/room_speed);
         }
         else
         {
            wallClingTimeS = 0;
            nextState = state.Falling;
         }
         
         if(kJump)
         {
            vy = -vyWallCling;
            vx = vxWallCling * -TouchingWall;
            nextState = state.Jumping;
         }
         
         break;
}

//add horizontal platform speed if we're on one
vx = vx + vxCarry;
vxCarry = 0;

//add vertical platform speed if we're on one
//(when I get it working)
vy = vy + vyCarry;
vyCarry = 0;


//set sprite direction left/right
if(dir != 0)
{
    image_xscale = dir;
}



//corner collisions
/*
if(place_meeting(x+(sign(vx)*ceil(abs(vx))), y+(sign(vy)*ceil(abs(vy))), oSolid))
{
    //if there's a wall to the left or right of us, don't let us walk through it
    //(warp sprite to touch if next frame would have been past collision)
    while(!place_meeting(x+sign(vx), y+sign(vy), oSolid))
    {
        //move towards
        x += sign(vx);
        y += sign(vy);   
    }
    //set speeds to 0 to stop moving
    vx = 0;
    vy = 0;
}
*/

//check if there is a solid on x axis
signVx = sign(vx);

if(place_meeting(x+(signVx*ceil(abs(vx))), y, oSolid))
{
  
    if(signVx == 1)
    { 
        x = floor(x);
    }
    else if(signVx == -1)
    {
        x = ceil(x);
    }
    
    //if there's a wall to the left or right of us, don't let us walk through it
    //(warp sprite to touch if next frame would have been past collision)
    while(!place_meeting(x+signVx, y, oSolid))
    {
        //move towards
        x += signVx;   
    }
    
    //set horizontal speed to 0 to stop moving
    vx = 0;
}

//check if there is a solid on y axis
signVy = sign(vy);
if(place_meeting(x, y+(signVy*ceil(abs(vy))), oSolid))
{
    if(signVy == 1)
    { 
        y = floor(y);
    }
    else if(signVy == -1)
    {
        y = ceil(y);
    }
    //if there's a wall above or below us, don't let us walk through it
    //(warp sprite to touch if next frame would have been past collision)
    while(!place_meeting(x, y+signVy, oSolid))
    { 
        //moving towards
        y += signVy;
    }

    //set vertical speed to 0 to stop moving
    vy = 0;
}

//commit state
State = nextState;

//commit movement
x += vx;
y += vy;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_text(16,16, string("x: " + string(x) + "y: " + string(y) + " | vx: " + string(vx) + " vy: " + string(vy)));
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
